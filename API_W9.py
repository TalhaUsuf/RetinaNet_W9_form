import os
import joblib
from pymongo import MongoClient
from pydantic import BaseModel,FilePath
from pathlib import Path
from typing import List
from fastapi import FastAPI, status
import random
import uvicorn
import numpy as np
import pandas as pd
import sqlite3
import shutil
import cv2
from pathlib import Path
from rich.console import Console
from rich.table import Table
from pdf2image import convert_from_path, convert_from_bytes
from utils import encode
from pqdm.threads import pqdm

app = FastAPI()

conn = sqlite3.connect(database="W9_logs.sqlite")



class verify_inp(BaseModel):
    picture: str

class output_model(BaseModel):

      """Used to validate the datatypes and structures to ensure data-integrity

      fpath will be used to store the input file path
      b64_imgs will save the input images as a list of b64 strings
      scores will save list of scores
      bboxes will store a list of lists containing bboxes coordinates
      classes will store a list of integers corresponding to classes indices
      w9_images will save list of string paths corresponding to W9 images
      other_images will save a list of string paths corresponding to other images
      """

      fpath : str
      b64_imgs : List[str]
      scores : List[List[float]]
      bboxes : List[List[List[float]]]
      classes : List[List[str]]
      w9_images : List[str]
      other_images : List[str]
      processed_images : List[str]
      w9_bool_filter : List[np.bool]



@app.get('/status')
async def status_(status_code=status.HTTP_200_OK):
      return {
      "status" : f"ALIVE"
      }


@app.post('/insert/{fpath:path}', response_model=output_model, status_code=status.HTTP_201_CREATED)
async def insert_to_db(fpath : str):
    assert type(fpath) == str , "path of file should be of string type"
    pth = Path(fpath)
    suff = pth.suffix
    if suff == ".tiff":
        ret, images = cv2.imreadmulti(Path(fpath).as_posix(), [], cv2.IMREAD_ANYCOLOR)



        print(f"{len(images)} images are found ... ")
        tab = Table(title="images shapes", title_style = "bold yellow on black",style="cyan")
        tab.add_column("shapes", style="green", justify="center")

        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        #                      debug the input images
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if os.path.exists("images_from_tiff_pdf"):
            shutil.rmtree("images_from_tiff_pdf")
        Path("images_from_tiff_pdf").mkdir(parents=True, exist_ok=True)

        for idx, i in enumerate(images):
            tab.add_row(f"{i.shape}")
            cv2.imwrite(f"images_from_tiff_pdf/{idx}.jpg", i)
            # cv2.imshow("frame", i)
            # k = cv2.waitKey() & 0xFF
            # if k == ord('q'):
            #     cv2.destroyAllWindows()
        

        Console().print(tab)

        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        #                      conver to base64
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        images = list(Path("images_from_tiff_pdf").glob("*.jpg"))
        images_ = [{"picture":k.as_posix()} for k in images]
        images_ = [verify_inp(**i) for i in images_]
        encoded_strings = pqdm(images_, encode, n_jobs=4)

        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        #                      do inference - single batch
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if os.path.exists("detections"): # if dir. already exists delete it
            shutil.rmtree("detections")
        Path("detections").mkdir(exist_ok=True, parents=True) # make a new dir for this experiment
        string_ = "   ".join([j.as_posix() for j in images])
        
        os.system(f"python demo/w9_predict.py  --config-file configs/custom.yaml  --input {string_} --output ./detections")

        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        #                      read the pkl files generated by
        #                   retina net stored in detections folder
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        preds = joblib.load(f"detections/preds.pkl")
        boxes = preds["pred_boxes"]
        scores = preds["scores"]
        cls = preds["pred_classes"]
        idx2cls = {i:k for i,k in enumerate(["tl1","tl2","c1","c2","p11","p12"])}
        cls_res = [[idx2cls[k] for k in m] for m in cls]
        processed_images = np.array(preds["images_processed"])
        
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        #                      decision logic   
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        filtered_w9 = np.array([True if len(k)>=2 else False for k in cls]).astype(np.bool)


        w9_imgs_paths = list(processed_images[filtered_w9])
        invoice_paths = list(set(list(processed_images)) - set(list(w9_imgs_paths)))
        
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        #    save the separated images as W9 images and invoice images in separate folders   
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        if os.path.exists("filtered_w9"):
            shutil.rmtree("filtered_w9")
        Path("filtered_w9").mkdir(parents=True, exist_ok=True)

        if os.path.exists("filtered_invoices"):
            shutil.rmtree("filtered_invoices")
        Path("filtered_invoices").mkdir(parents=True, exist_ok=True)

        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        #                      copy to the respective dirs.
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

        [shutil.copy(w9, "filtered_w9") for w9 in w9_imgs_paths]
        [shutil.copy(inv, "filtered_invoices") for inv in invoice_paths]

        w9_resonse = list(Path("filtered_w9").glob("*.jpg"))
        w9_resonse = [k.as_posix() for k in w9_resonse]
        invoice_resonse = list(Path("filtered_invoices").glob("*.jpg"))
        invoice_resonse = [c.as_posix() for c in invoice_resonse]
        # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    #                      for pdf files
    # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    # with Console().status("processing pdf ... ", spinner="bouncingBall"):
    #
    #     images = convert_from_path("/home/talha/Downloads/Andrew Parr - Hydraulics and Pneumatics_ A Technician's and Engineer's Guide, Second Edition (1999) - libgen.lc.pdf")
    #
    #     Console().print([i.shape for i in images])
    # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      # insert somethinmg to database
      # with MongoClient() as client:
      #       logs = client["W9"]["API_LOGS"]

      #       dummy = {
      #             "fpath" : "dummy_path",
      #             "b64_imgs" : ["this", "is", "a", "dummy", "string"],
      #             "scores" : [1.2,561.5, 2.5,6.5,5.5],
      #             "bboxes" : [[1.2, 55, 56, 560], [54, 564, 56, 584]],
      #             "classes" : [1, 52 , 5, 54],
      #             "w9_images" : ["sdgdfsgdf", "dsgdfsgdfgdf0"],
      #             "other_images" : ["dsgfdsgdf", "dsgdsg"],
      #             }
            # logs.insert_one(dummy)
      # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      #
      #                 recognize the file extension
      #                 read the file
      #                 save images in separate dirs and make list
      #                 convert them into base64 strings and make list
      #                 loop over images and apply detection
      #                 make a list 'detections' and [1,0,0,1,1,1,0] 0 for not W9 image and 1 for W9 image
      #                 save those images to a separate directory.
      #
      # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


      # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      #                  do recognition here
      # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

      # %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        resp = {
        "fpath" : f"{fpath}",
        "b64_imgs" : encoded_strings,
        "scores" : scores,
        "bboxes" : boxes,
        "classes" : cls_res,
        "w9_images" : w9_resonse,
        "other_images" : invoice_resonse,
        "processed_images":list(processed_images),
        "w9_bool_filter" : list(filtered_w9),
        }

        return resp





# @app.get('/recognize', response_model=output_model)
# async def recognition(file_input : input_model):

#       with MongoClient() as client:
#             logs = client["W9"]["API_LOGS"]
#             logs.insert_one(file_input.dict())
#       return {

#       }


if __name__=='__main__':
      # uvicorn.run("API_W9:app", port=8080, limit_concurrency=4, workers=4)

      # uvicorn.run("API_W9:app", port=8080, limit_concurrency=4, reload=True)
      uvicorn.run("API_W9:app", port=8080, reload=True)
